# -*- Mode: POLY-ORG;  -*- ---
#+Title: Lilith: Literate Programming for Common Lisp in ORG Mode.
#+Author:  Alan Ruttenberg
#+Startup: noindent
#+SubTitle: Just in one file without tangle
#+OPTIONS: tex:t toc:2 \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+STARTUP: latexpreview
#+STARTUP: noindent
#+STARTUP: inlineimages
#+PROPERTY: literate-lang lisp
#+PROPERTY: literate-load yes
#+STARTUP: entitiespretty
#+COMMENT: toc-org-insert-toc to update 
* Table of Contents                                               :noexport:TOC:
- [[#introduction][Introduction]]
  - [[#terminology][Terminology]]
- [[#implementation-strategy][Implementation strategy]]
  - [[#reading][Reading]]
  - [[#working-with-code-chunks][Working with code chunks]]
  - [[#leveraging-asdf][Leveraging ASDF]]
- [[#implementation][Implementation]]
  - [[#preparation][Preparation]]
  - [[#reading-the-org-file][Reading the org file]]
  - [[#working-with-strings-representing-code][Working with strings representing code]]
  - [[#working-with-code-chunks-1][Working with code chunks]]
  - [[#tangling-the-org-file][Tangling the org file]]
  - [[#ensuring-that-code-chunk-references-are-expanded-when-loading-or-compiling][Ensuring that code chunk references are expanded when loading or compiling]]
  - [[#asdf-support-for-org-file-as-source-code][ASDF support for org file as source code]]
- [[#release-this-file][Release this file]]
- [[#test-cases][Test cases]]
  - [[#preparation-1][Preparation]]
  - [[#test-groups][test groups]]
  - [[#run-all-tests-in-this-library][run all tests in this library]]
  - [[#run-all-tests-in-demo-project][run all tests in demo project]]
- [[#bugs][Bugs]]
- [[#ideas-and-plans][Ideas and Plans]]
  - [[#final-setup][Final setup]]
- [[#references][References]]

* Introduction
Lilith enables [[http://www.literateprogramming.com/][literate programming]] in Common Lisp, leveraging
Emacs' [[https://orgmode.org/][org mode]] along with other emacs packages. Lilith is inspired by [[https://github.com/jingtaozf/literate-lisp][Jingtao Xu's Literate Lisp project]],
and started as a fork of that project. 

Literate programming is a style of writing code in the way you would write
explanatory prose. Code can be broken down in a way that supports the narrative,
even breaking functions up into separate, even out of order, chunks in the
prose.  At the same time the code can be put together for the purpose of running
it.  Traditional literate programming tools support taking what you've written
and generating two products. One a nicely typset document suitable for
publication, and the other a plain source code file that can be compiled and
executed.  Lilith, in part, supports that workflow.

We take this further by enabling the org file to act as the source
file. Just as you would use [[https://common-lisp.net/project/slime/][SLIME]] to work with a lisp file in emacs, the
project makes it possible to work with SLIME in an org file. Rather than
having to generate a lisp source file to use with tools, the org file
becomes the source file directly. The org can be loaded, compiled and
included as source file in an ASDF system definition.

Org mode makes it possible to edit, eval and run code from within the org
mode buffer.  However babel's editing support is as generic text. For
example, there is no support for indentation or navigating to other
definitions. The elisp library [[https://polymode.github.io/][polymode]] enhances that by arranging that as
you move into a source code block slime-mode becomes active.

Org mode also makes it possible lisp code to generate content that is
included in the org file. For example some lisp code might generate a figure 
that is subsequently included in the document. 

To summarize, Lilith supports several different ways of writing
(code).  You can use the org files directly as your source files, or export
to pure lisp source files that can be used and distributed without needing
the environment installed. or source code in the file generate content that
is included in the document.

** Terminology

When talking about literate programming it will be helpful to name a few things.

A [[https://orgmode.org/worg/org-contrib/babel/intro.html#source-code-blocks-org][*source block*]] is a section in the org file delimited by /#+begin_src/ and
/#+end_src/, but not within an org [[https://orgmode.org/manual/Comment-lines.html][comment]] or [[https://orgmode.org/manual/Literal-examples.html][example]].

A *lisp source block* is a common lisp source block.

A *form* is a lisp sexp

A *code chunk* is a lisp source block with one or more forms, typically a code fragment.
Code chunks have names so they can be referenced in other code that uses them.

A *code chunk reference* is a way to specify by name what code chunk should be
substituted in it's place.  

To *tangle* an org file is to transform it in to a lisp source code file that can be loaded by
a lisp implementation unaware of org syntax or Lilith.

* Implementation strategy
** Reading 

In org mode, comment lines start with character ~#~ (see [[https://orgmode.org/manual/Comment-lines.html][org manual]] ),
and lisp code is put between ~#+begin_src lisp~ and ~#+end_src~
(see [[https://orgmode.org/manual/Literal-examples.html][org manual]]). Here's an example.

#+BEGIN_EXAMPLE
   ,#+BEGIN_SRC lisp :load no
   (format t "this is a test.~%")
   ,#+END_SRC
#+END_EXAMPLE

If we want lisp to use an org file directly, all text outside the markers
~#+begin_src lisp~ and ~#+end_src~ should be ignored. How do we accomplish that?

We do this with by exploiting Common Lisp's ability to modify [[https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node187.html][reader syntax]].
The trick is to add a reader macro for "# "([[http://clhs.lisp.se/Body/02_dhu.htm][Sharpsign Whitespace]]), under
the assumption that the first line in org file will start with "#" space.
The macro ignores all lines until it sees ~#+BEGIN_SRC lisp~. It then 
can read source as usual until it gets to ~#+END_SRC~. When the reader reads 
"#+"([[http://clhs.lisp.se/Body/02_dhq.htm][Sharpsign Plus]]) it invokes the existing reader macro enabling conditional reading depending on *features* 
We modify that reader to not interpret ~END_SRC~ as a feature and instead to
keep reading over org text until it arrives at the next ~#+BEGIN_SRC lisp~.

While you can still use ~#+~ style conditional reading we also enable a second way.
Org mode allows The ~#+begin_src lisp~ line to have additional information in the form of
[[https://orgmode.org/manual/Code-block-specific-header-arguments.html#Code-block-specific-header-arguments][header arguments]]. Based on those headers we can decide whether the code should 
be read otherwise be handled. The # space reader can read those headers and based on them
act differently, for example by continuing to read over that code without interpreting it.
Future work may offer new capabilities based on headers, for example to direct that
when creating lisp source this portion should be put in a different file.

While this workflow requires the org file to start with "# ", this
shouldn't be a problem. First, org mode considers a line starting with "# "
to be a comment, so the line need not be visible in the presentation
document. Second, consider it a convenient way for us to specify some local
variables, for example you can the first line of an org file be something
like this,

#+BEGIN_SRC org
# -*- encoding:utf-8 Mode: POLY-ORG;  -*- ---
#+END_SRC

which make Emacs open the file with utf-8 encoding and in [[https://github.com/polymode/poly-org][poly-org-mode]].

** Working with code chunks

We want to support breaking functions up into pieces that can be put back
together appropriately. Here's the syntax.

| (:@  name)          | replace with the actual chunk by that name                            |
| (:@+ name body)     | Add body to the code chunk named                                      |
| (:@. name  freetext | Add the text, appropriately escaped for lisp, to the code chunk named |

Currently names need to be surrounded by "|", as well as freetext.
There can be multiple :@+ forms with the same name - the contents are
concatenated.  Some care may be need to be take for the freetext within a lisp
form - it tends to confuse slime mode. You always surround the text with "|" to
protext against that.

To support this we have to handle two cases, having Common Lisp load and
compile the org file, and tangling the org file to create lisp source.
These are handled in separate ways. Both ways are supported by doing a
first pass over the file to collect the code chunks, which may defined
after they are used.

To tangle the file, the file is read again, substituting the code chunks
for code chunk references.

When having lisp load or compile the file we need to hook some Common Lisp
functions so that they first collect the code chunks before doing their
normal processing. For loading it is sufficient to modify defun to first
walk the body and replace code chunk references with their chunk before
doing it's usual work.

Compilers don't always macroexpand the defun forms. For those compilers we
need to modify the function that /does/ process the defuns. Of the
compilers tested thus far, ABCL and Allegro need this treatment. 
ABCL is implemented, but not yet Allegro.

** Leveraging ASDF
ASDF allows one to define new components. We'll define one called :org and add
some logic for compiling and loading.
* Implementation
** Preparation

Firstly a new lisp package for this library is defined.
#+BEGIN_SRC lisp
(in-package :common-lisp-user)
(defpackage :lilith
  (:use :cl)
  (:nicknames :lp)
  (:export :tangle-org-file)
  (:documentation "a literate programming tool to write Common Lisp codes in org file."))
(pushnew :lilith *features*)
(in-package :lilith)
#+END_SRC

Define globals
#+begin_src lisp
  (:@ |defvars|)
#+end_src

There is a debug variable to switch on/off the log messages.
#+BEGIN_SRC lisp
(defvar debug-lilith-p nil)
(declaim (type boolean debug-lilith-p))
#+END_SRC

** Reading the org file

This support function skips over whitespace. 

#+BEGIN_SRC lisp
(defun start-position-after-space-characters (line)
  (loop for c of-type character across line
        for i of-type fixnum from 0
        until (not (find c '(#\Tab #\Space)))
        finally (return i)))
#+END_SRC

*** Let a header argument determine whether to load
The org file may have source code for different purposes, for example
implementation, demonstration, and testing. To support this a new [[https://orgmode.org/manual/Structure-of-code-blocks.html][org code block]] [[https://orgmode.org/manual/Code-block-specific-header-arguments.html#Code-block-specific-header-arguments][header argument]]  ~load~ is used to indicate
whether the code should be used or not. The possible values are:
|yes|The current code block should load normally. This is the default mode when the header argument ~load~ is not provided.
|no|The current code block should ignore by lisp reader. |
|test|The current code block is test related.|
|<keyword> |The block should load only when feature the keyword is present in [[http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm][~*features*~]].|

To control whether test related code should be loaded, we use the keyword ~:lilith-test~.

This function evaluates whether or not a code block should be loaded, based on the load header argument.
When it sees :test it only returns true if ~:lilith-test~ is in ~*features*~. 
#+BEGIN_SRC lisp
(defun load-p (feature)
  (case feature
    ((nil :yes) t)
    (:no nil)
    (:test (find :lilith-test *features* :test #'eq))
    (t (find feature *features* :test #'eq))))
#+END_SRC

Now code to read [[https://orgmode.org/manual/Code-block-specific-header-arguments.html#Code-block-specific-header-arguments][header arguments]] after ~#+BEGIN_SRC lisp~,
and convert every key and value to a lisp keyword (see test in [[block header test]]).

#+BEGIN_SRC lisp
(defun read-org-code-block-header-arguments (string begin-position-of-header-arguments)
  (with-input-from-string (stream string :start begin-position-of-header-arguments)
    (let ((*readtable* (copy-readtable nil))
          (*package* #.(find-package :keyword))
          (*read-suppress* nil))
       (loop for elem = (read stream nil)
                     while elem
                     collect elem))))
#+END_SRC

*** Sharp space reader

The function ~sharp-space~ is called when the reader sees "# ", and reads until
the next ~#+begin_src~ that isn't nested inside a comment or example.  If it
sees ~#+begin_comment~, it keeps reading and ignoring until it reaches
~#+end_comment~. If it sees ~#+begin_example~ it keeps reading until
~#+end_example~, but the text between them is considered worth having
in the tangled file.

It coordinates with tangle-org-file via three globals ([[global tangling]]).

If *tangle-keep-org-text* is non-nil those lines
are written to  *tangling-stream*. If *tangling-verbatim* is non-nil the lines
are written verbatim, otherwise they are written as lisp comments. Those 
variables are bound when tangling. During non-tangle reading have no effect.

It then reads the block headers and the source block. Depending on the header
it either emits the source block as code, or considers it plain org text.

#+begin_src lisp
(defun sharp-space (stream a b)
  (declare (ignore a b))
  (when (and *tangling-to-stream* *tangle-keep-org-text*)
    (terpri *tangling-to-stream*))
  (macrolet ((looking-at (what)
	       `(eql start1 (search ,what line :test #'char-equal))))
    (loop for line = (read-line stream nil nil)
	  with waiting-for = nil
	  until (null line)
	  for start1 = (start-position-after-space-characters line)
	  do
	     (when debug-lilith-p
	       (format t "ignore line ~a~%" line))
	     (:@ |handle entry to an example or comment|)
	     (:@ |maybe write an ignored line to tangled file|)
	     (if (looking-at waiting-for)
		 (setq waiting-for nil))
	  until (and (not waiting-for) (looking-at "#+begin_src lisp")
	       (let* ((header-arguments (read-org-code-block-header-arguments
					 line 
					 (+ start1 (load-time-value (length "#+begin_src lisp"))))))
		 (load-p (getf header-arguments :load :yes))))))
  (when (and *tangling-to-stream* *tangle-keep-org-text*)
    (terpri *tangling-to-stream*))
  (values))
#+end_src

We handle comments and examples by setting the variable waiting-for
to the corresponding end marker

#+begin_src lisp
(:@+ |handle entry to an example or comment|
     (when (not waiting-for)
       (progn
	 (when (looking-at "#+begin_comment")
	   (setq waiting-for "#+end_comment"))
	 (when (looking-at "#+begin_example")
	   (setq waiting-for "#+end_example")))))
#+end_src

We'll print the current line to the tangled file as long as *tangling-to-stream* is bound.
If verbatim write it out as is. Otherwise write it out unless it's org comments.
#+begin_src lisp
(:@+ |maybe write an ignored line to tangled file|
     (when *tangling-to-stream*
       (if *tangling-verbatim*
	   (write-line line *tangling-to-stream*)
	   (unless 
	       (:@ |should the current line be printed as a comment?|)
	     (write-string ";; " *tangling-to-stream*)
	     (write-line line *tangling-to-stream*)))))
#+end_src

We won't print the line if
- it's an empty string
- we have or have been waiting for an end_example, but the line isn't the start of end directive.
- we're not including org text at all 
- It's a comment, either because it's first character is "#" or because it's in an extended #+ comment.
#+begin_src lisp
(:@+ |should the current line be printed as a comment?|
     (or (and (equal waiting-for "#+end_example")
	      (or (looking-at "#+begin_example")
		  (looking-at "#+end_example")))
	 (and (not waiting-for)
	      (eql 0 (position #\# line :test 'char=)))
	 (equalp waiting-for "#+end_comment")
	 (ppcre::scan "^\\s*$" line)
	 (not *tangle-keep-org-text*)))
#+end_src
	   
*** Sharp plus reader
The #+ sharp-plus reader adds logic modifies the behavior of standard #+.  When this
function is called it reads the next thing (setting *package* to the keyword
package) the result of which is a putative [[http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm][feature specification]]. First we check
whether what was read was :END_SRC. If so, that's not a feature specification
but instead a signal that we are moving from a code block to regular org text,
and the sharp-plus reader is called again.

Otherwise it calls featurep to see whether the feature specification is
satisfied and if so it reads the next object. If it is not satisfied it passes
over the object by use of [[http://www.lispworks.com/documentation/HyperSpec/Body/v_rd_sup.htm][~*read-suppress*~]].

#+BEGIN_SRC lisp
(defun sharp-plus (stream sub-char numarg)
  (let ((feature (let ((*package* #.(find-package :keyword)))
		   (read stream t nil t))))
    (when debug-lilith-p
      (format t "found feature ~s,start read org part...~%" feature))
    (cond ((eq :end_src feature) 
	   (when debug-lilith-p
	     (format t "found #+END_SRC,start read org part...~%"))
	   (funcall #'sharp-space stream sub-char numarg))
          ((uiop/os:featurep (or feature (subst :lilith-test :test feature)))
	   (read stream t nil t))
          (t (let ((*read-suppress* t)) (read stream t nil t) (values))))))
#+END_SRC
*** Define and initialize a readtable 

Let's use a new read table to hold the reader for org syntax.
#+BEGIN_SRC lisp
(defvar *org-readtable* (copy-readtable))
#+END_SRC

We will need to install the reader macros we defined in our readtable. This
is a code chunk - the actual installation is done near the end of the file.
#+begin_src lisp
(:@+ |set read table dispatch functions|
  (set-dispatch-macro-character #\# #\space #'sharp-space *org-readtable*)
  (set-dispatch-macro-character #\# #\+ #'sharp-plus *org-readtable*))
#+end_src

Define a macro to invoke use *org-readtable*
#+begin_src lisp
(defmacro with-literate-syntax (&body body)
  `(let ((*readtable* *org-readtable*))
  ,@body))

#+end_src  
** Working with strings representing code 

When tangling the org file, and when working with code chunks, we will mostly
use and manipulate strings rather than forms. 
A string of a code chunk can have several forms, and a code chunk can comprise several strings.

read-forms-from-string takes a string as input, and reads each form in
the string, returning a list of forms.

#+begin_src lisp
(defun read-forms-from-string (string)
  (with-input-from-string (s string)
    (loop for form = (read s nil :eof)
	  until (eq form :eof)
	  collect form)))
#+end_src

get-forms-as-strings takes a string with a number of forms and returns a list of
strings, each the string representation of one of the forms.

We use read *read-suppress* in order to avoid side-effects, and in order to
group feature specifications with their subsequent form.  However, due to a [[https://github.com/armedbear/abcl/issues/123][bug
in ABCL]], we use file-position to detect when we've hit end of file instead of
using read's eof-error-p and eof-value.  Fix this when Roswell's ABCL
implementation is updated.

#+begin_src lisp
(defun get-forms-as-strings (string)
  (loop for lastpos = 0 then pos
	with stream = (make-string-input-stream string)
	for pos = (if (= (file-position stream) (length string))
		      :eof
		      (let ((*read-suppress* t))
			(read stream nil nil) ; need this because you might have "#+nil foo" in a src block
			(file-position stream)))
	until (eq pos :eof)
	collect (subseq string lastpos pos)))
#+end_src

** Working with code chunks

*** The storage and creation of code blocks
Let's store all named code blocks in a hash table.
The key is ~|code block name|~, it can be any lisp object only if they can compare with ~equalp~.
#+begin_src lisp
(:@+ |defvars| 
  (defvar named-code-blocks nil))
#+end_src

*** Collecting code chunks
In order to handle cases where the code blocks are defined after they
are used, a separate pass is used to collect the code blocks which will
subsequently be used to substitute for the code chunk references.
Code chunks have the (:@+ |name| code). 

gather-code-chunks returns a hash table with the keys being names of
code chunk and the values being a list of strings comprising the code chunk.
We check to make sure we aren't redefining a code chunk, and that
when we are adding the code chunk there's already one there to add to.

#+begin_src lisp
(defun gather-code-chunks (org-file)
  (let ((code-blocks (make-hash-table :test 'equalp)))
    (each-source-form-as-string
     org-file
     (lambda(block)
       (cl-ppcre::register-groups-bind (op name body)
	   ("(?s)^\\s*[\"]*\\((:@[+.])\\s+\\|([^|]+)\\|\\s*(.*)\\)" block)
	 (if (equal op ":@+")
	     (push body (gethash name code-blocks))
	     (push (concatenate 'string "\"" (ppcre::regex-replace-all  "\"" body "\\\"") "\"")  
		   (gethash name code-blocks))))
       ))
    code-blocks))
#+end_src

*Note*: named-code-blocks is only used dynamically so it might as well be initialized to nil.

*** Iterating over code chunks as strings
each-source-block-as-string calls fn on each lisp source block, as
string, in the org file. We will use it when tangling the code.

#+begin_src lisp
(defun each-source-block-as-string (org-file fn)
  "Call fn on each source code block string in the org file"
    (with-open-file (input org-file)
      (block read-org-files
	(loop for nil = (sharp-space input nil nil)
	      until (eq (peek-char nil input nil :eof) :eof)
	      ;; read codes in code block until reach `#+end_src'
	      do (loop with output = (make-string-output-stream)
		       for line = (read-line input nil nil)
		       do
			  (cond ((null line)
				 (error "End of file while in source block '~a'" (get-output-stream-string output)))
				((string-equal "#+end_src" (string-trim '(#\Tab #\Space) line))
				 (when debug-lilith-p
				   (format t "reach end of source code block.~%"))
				 (funcall fn (get-output-stream-string output))
				 (return t))
				(t (when debug-lilith-p
				     (format t "read code line:~s~%" line))
				   (write-line line output))))))))
#+end_src

A source block might have several forms, either lisp definitions, or code chunks.
each-source-form-as-string calls *fn* on each separate form in each lisp src block.
We'll use this when gathering code chunks.

#+begin_src lisp
(defun each-source-form-as-string (org-file fn)
  (each-source-block-as-string
   org-file
   (lambda (block)
     (if (ppcre::scan "\\s*\\(:@." block)
	 (funcall fn block)
	 (map nil fn (get-forms-as-strings block))))))
#+end_src

*** Translate forms as strings with chunk references to ones with the actual chunks
Code chunks can be substituted into source blocks or other code chunks.
Substitution is done recursively. If a reference to a code chunk is found, and
the code chunk refers to another code chunk, that is also substituted.

First define a helper /replace-all/, using [[https://edicl.github.io/cl-ppcre/][cl-ppcre]].
- string is source which will be modified
- regex matches pieces that will be substituted
- which specifies the groups that will be passed to function
- function is called with the specified groups and returns a string replacement.

Note that when there are nested groups, the string being replaced
will be that of the outermost group.

#+begin_src lisp
(defun replace-all (string regex function &rest which)
  (cl-ppcre::regex-replace-all
   regex string
   (lambda (target-string start end match-start match-end reg-starts reg-ends)
     (declare (ignore target-string start end ))
     (apply function
	    (loop for group in which
		  if (= group 0)
		    collect (subseq string match-start match-end)
		  else
		    collect (subseq string (aref reg-starts (1- group)) (aref reg-ends (1- group))))))))
#+end_src

The test shows an example where numbers are translated into their english words.
#+begin_src lisp :load test
(:@+ |tests|
 (5am:test replace-all
  (5am:is (equal "one two three"
		 (replace-all "1 2 3" "(\\d+)"
			      (lambda(e) (format nil "~r" (parse-integer e)))
			      1)))))
#+end_src

In order to avoid an infinite loop because of circular use of code chunk
references, we keep track of what we are substituting, recurively, with the
variable *trace-substitutions*

#+begin_src lisp
(:@+ |defvars|
     (defvar *trace-substitution* nil))
#+end_src

The input argument to maybe-substitute-code-block is the form (as string) for
which substitution should be done. code-chunks is the hash created by
gather-source-chunks.

We make some make some effort here to present the substituted chunks reasonably.

#+BEGIN_SRC lisp
(defun maybe-substitute-code-block (input code-chunks)
  (replace-all input "(?s)(\\(:@\\s*\\|([^|]+)\\|\\s*\\))"
	       (lambda(whole name)
		 (let* ((:@ |figure out indentation|))
		   (assert (gethash name code-chunks) () "Code block '~a' called for, but not defined" name)
		   (if (member name *trace-substitution* :test 'equalp)
		       (error "Circularity in code blocks: |~a| uses ~{|~a|~^ uses~}"
			      name (reverse *trace-substitution*))
		       (let ((*trace-substitution* (cons name *trace-substitution*)))
			 (:@ |compute string to insert|)))))
	       1 2))
#+end_src

To find the indentation, we split the source block into lines, find the first
line containing the chunk reference, and use the position in that line to
determine indentation of the chunk.

#+begin_src lisp
(:@+ |figure out indentation|
     (pos (some (lambda(e) (search whole e :test 'char=))
		(cl-ppcre::split "\\n" input)))
     (indent (subseq (load-time-value (format nil "~80:a" " ")) 0 pos)))
#+end_src

For the insertion, first, we leave a comment naming the chunk when we insert the
chunk. Second, We try to indent properly by splitting the chunk into separate forms,
trimming leading spaces, and prepending by the computed indentation.

/This doesn't work well - fix/

#+begin_src lisp
(:@+ |compute string to insert|
     (format nil ";; Using |~a|~%~{~a~}" name
	     (mapcar (lambda(e)
		       (format nil "~a"
;			       (ppcre::regex-replace-all
;				"(?m)(^\\s*)"
				(maybe-substitute-code-block e code-chunks)
				;;				indent)
				))
		     (gethash name code-chunks))))
#+END_SRC

*** Translate forms with chunk references to ones with the actual chunks.

This code handles the case when we are evaluating, loading, or compiling. It
is not used in tangling to a file. 

This macro is responsible for retrieving a code chunk, which is represented as a
list of strings, into a list of forms used in the transformations.

#+begin_src lisp
(defmacro with-code-chunk ((name codes) &body body)
  (let ((present-p (gensym "PRESENT-P"))
        (code-block-name (gensym "NAME")))
    `(let ((,code-block-name ,name))
       (let* ((,present-p (gethash (string ,code-block-name) named-code-blocks))
	      (,codes (mapcan 'read-forms-from-string ,present-p)))
         (unless ,present-p
	   (inspect named-code-blocks)
           (error "Can't find code block:~a" ,code-block-name))
           ,@body))))
#+end_src

Our function expand-web-form walks through a lisp form and replaces all chunk
references with their chunks. Those chunks may need expansion as well, so
this is done recursively. Some [[tests for web syntax]] are here.

#+begin_src lisp
(defun expand-web-form (form)
  (if (atom form)
      form
      (if (eq (car form) :@)
	  (expand-web-form `(progn ,form))
	  (loop for previous-form = nil then left-form
		for left-form = form then (cdr left-form)
		until (or (null left-form)
			  ;; to a dotted list, its `cdr' may be an atom.
			  (atom left-form))
		when (listp (car left-form))
		  do (let ((head (caar left-form)))
		       (cond ((eq head 'quote) nil) ; ignore a quote list.
			     ((eq head :@) 
			      (with-code-chunk ((second (car left-form)) codes)
				(unless codes
				  (error "code block ~a is null for syntax :@" (second (car left-form))))
				;; support recursive web syntax in a code block by expanding the defined code block
				(let* ((copied-codes (expand-web-form (copy-tree codes)))
				       (last-codes (last copied-codes)))
				  ;; update next form
				  (setf (cdr last-codes) (cdr left-form))
				  ;; update left-form
				  (setf left-form last-codes)
				  (if previous-form
				      (setf (cdr previous-form) copied-codes)
				      (setf form copied-codes)))))
			     (t (setf (car left-form) (expand-web-form (car left-form))))))
		finally (return form)))))
#+end_src

*** Define the chunk definition as a noop
All work of processing these is in gather-code-chunks. If lisp happens to evaluate them
then nothing bad happens.
#+begin_src lisp
(defmacro :@+ (name &body body)
  (declare (ignore name body)))
(defmacro :@. (name &body body)
  (declare (ignore name body)))
#+end_src

** Tangling the org file

Argument ~keep-tests~ is a Boolean value to indicate whether test codes should load.
#+begin_src lisp
(defun tangle-org-file (org-file &key
				   (keep-tests nil)
				   (output-file (make-pathname :defaults org-file
							       :type "lisp"))
				   verbatim
				   (keep-org-text t))
  (let ((*features* (if keep-tests
			(cons :lilith-test *features*)
			*features*))
	(code-blocks (gather-code-chunks org-file))
	(*tangling-verbatim* verbatim)
	(*tangle-keep-org-text*  keep-org-text))
    (with-open-file (output output-file :direction :output
					:if-does-not-exist :create
					:if-exists :supersede)
      (:@ |write header|)
      (let ((*tangling-to-stream* output))
	(each-source-block-as-string
	 org-file
	 (lambda(block)
	   (:@ |write out block with code chunks substituted|)))
	(when *tangling-verbatim*
	  (format *tangling-to-stream* "#+END_SRC~%"))))
	)) 
#+end_src

Checks to see whether this block is a code chunk reference, and if so, substitutes the
code chunk.

#+begin_src lisp
(:@+ |write out block with code chunks substituted|
  (if (ppcre::scan "^\\s*\\(:@[+.]" block)
      ;; comment out code chunks
      (format *tangling-to-stream* "~{;; ~a~%~}" (cl-ppcre::split "\\n" block))
      (write-string (maybe-substitute-code-block block code-blocks) output)))
#+end_src

Write a header to the beginning of the tangled file. Explain that it's a generated
file. Then, if we're including the org text, say so, and if not warn that you probably
need to read the org file to understand it.

#+begin_src lisp
(:@+ |write header|
  (macrolet ((in-a-comment (s &rest args)
	       `(format output "~{;;; ~a~%~}"
			(ppcre::split "\\n" (format nil (string ,s) ,@args)))))
  (unless *tangling-verbatim*
    (in-a-comment (:@ |explain source|)
		  (pathname-name org-file) (pathname-type org-file)))
  (if *tangle-keep-org-text*
      (in-a-comment (:@ |explain comments|))
      (in-a-comment (:@ |warn no comments|)))))
#+end_src


#+begin_src lisp
(:@. |explain source|
|This file is automatically generated from the lilith file '~a.~a'.
It is meant to be loaded by a common lisp directly, without depending on Lilith|)
#+end_src

#+begin_src lisp
(:@. |explain comments|
|This file keeps all text in the original file as lisp comments, except
for the org-mode comments and directives.|)
#+end_src

#+begin_src lisp
(:@. |warn no comments|
|The file is not intended to be read directly as it omits all non-code text from the source.
See the source for full usage and documentation|)
#+end_src

*** The globals that control tangling
<<global tangling>>
*tangling-to-stream* is bound to a stream when we want to also output org mode
text to the tangled file.

*tangling-keep-org-text* controls whether to copy to the org mode text, as
lisp comments, to the tangled file.

*tangling-verbatim* if non-nil has the org mode text copied, verbatim, to the
tangled file. Mostly for debugging. Sort of recreates the original file, but
with the substitutions done.

#+begin_src lisp
(:@+ |defvars|
  (defvar *tangling-to-stream* nil)
  (defvar *tangle-keep-org-text* nil)
  (defvar *tangling-verbatim* nil)
  )
#+end_src
*** Testing tangling

Tangle the org file, load the tangled file, tangle the org file again and then make sure
they are same.

#+begin_src lisp
(defun files-same? (file1 file2)
  (equal "" (with-output-to-string (s)
  (uiop/run-program:run-program
  (format nil "diff ~a ~a" (truename file1) (truename file2))
  :output s))))
#+end_src
						   
Test that we can re-generate lilith

#+begin_src lisp :load test
(:@+ |tests|
  (5am:test tangle-ok?
    (5am:is 
     (let ((org-path (asdf/system::system-relative-pathname 'lilith "lilith.org")))
       (pushnew :lilith-test *features*)
       (let ((file1 (merge-pathnames "ll-1.lisp" uiop/stream:*temporary-directory*))
	     (file2 (merge-pathnames "ll-2.lisp" uiop/stream:*temporary-directory*)))
	 (tangle-org-file org-path  :output-file file1 :keep-tests t)
	 (erase-lilith)
	 (rename-package "LILITH" (gensym))
	 (load file1) 
	 (funcall (intern "TANGLE-ORG-FILE" 'lp)  org-path  :output-file file2 :keep-tests t)
	 (files-same? file1 file2))))))
#+end_src

** Ensuring that code chunk references are expanded when loading or compiling

There are several aspects making loading and compile work. First we hook
common lisp's load and compile-file to first build the hash table
named-code-blocks before proceeding. Then we hook degun to transform its arguments
and body using expand-web-form. This still leaves top-level chunk references
untouched. For those we define :@ as a macro that wraps the code chunk into
a progn.

#+begin_src lisp
(defmacro :@ (&whole whole name)
  (declare (ignore name))
  (expand-web-form `(progn ,whole)))
#+end_src

You might as why we need to bother patching defun and instead stop at the :@
macro.  We don't because macros are not expanded in all places, for example in
the bindings section of let, and we want to be able to substitute a code chunk
anywhere.

One obstacle is that not all compilers evaluate the defun while compiling and
this requires patching elsewhere in the compiler. Another obstacle is that a
number of lisps have mechanisms to protect against accidental modification of
the bases system, including all the symbols in the common-lisp package. We'll
start addressing that first.

*** Handling protection
Each system that has this protection implements it in a different way, often
focused on locking changes to a package.  This code provides a macro to unlock,
if necessary, the common-lisp package, conditionalized for a number of lisps,
with the default being to do nothing. It has been tested using Roswell for
abcl-bin, ccl-bin, sbcl-bin, ecl, cmu-bin, and allegro. Please submit an issue
or pr if you are using a lisp that isn't handled correctly here. I don't 
currently have access to lispworks, but the author of literate lisp has 
shown how to /advise/ functions in lispworks so we'll use that in the lispworks 
implementation ([[lispworks implementation]]).


#+begin_src lisp
(defmacro without-cl-locked (&body body)
  `(#-(or SBCL CCL CMU ECL ALLEGRO) progn
     #+SBCL sb-ext::without-package-locks
     #+CCL let #+CCL ((CCL:*WARN-IF-REDEFINE-KERNEL* nil))
     #+CMU extensions::without-package-locks
     #+ECL let #+ECL ((SI:*IGNORE-PACKAGE-LOCKS* t))
     #+ALLEGRO  EXCL:WITHOUT-PACKAGE-LOCKS
     ,@body))
#+end_src 

*** Hooking defun 
We will change defun dynamically, only when we are loading or compiling an
org file. While expand-web-form can be safely applied even when there are code chunks,
why tempt fate. 

I'm still exploring just exactly when we should hook defun. It isn't sufficient
to only hook when the file being loaded or compiled is an org file, as
evaluation can happen when loading fasls as well. Right now the answer is
always. Some of the alternative components are in the comments.

#+begin_src lisp
(defun in-a-context-where-we-should-use-expand-web-form () t)
;; (member (pathname-type path) (load-time-value (list (uiop/lisp-build:compile-file-type) "org"))
;;		    :test 'equalp))
#+end_src 

This macro uses unwind-protect to be able to dynamically bind any lisp /place/.

#+begin_src lisp
(defmacro letf-without-cl-lockeds (bindings &body body)
  (if (null bindings)
      `(progn ,@body)
      (let ((save (gensym)))
	`(let ((,save ,(caar bindings)))
	   (letf-without-cl-lockeds ,(cdr bindings)
	     (unwind-protect (progn
			       (without-cl-locked
				 (setf ,(caar bindings) ,(second (car bindings))))
			       ,@body)
	       (without-cl-locked
		 (setf ,(caar bindings) ,save))))))))
#+end_src 

We'll need to save the values of the original functions to restore them 
after we've changed them. While most of the lisps expand defun when compiling,
ABCL doesn't and so we need to hook a compiler function: jvm::compile-defun.

#+begin_src lisp
(:@+ |defvars|
(defvar *save-defun* (macro-function 'defun))
#+ABCL
(defvar *save-compile-defun* #'jvm::compile-defun)
)
#+end_src


Define a macro to shadow defun when working with org files. We can do that
because macro functions are accessible and can be called. We just have
to make sure the lexical environment is intact by getting it in our macro
using &environment and passing it as the second argument to the macro function.
The first argument to the macro function is the whole form, which we reconstruct,
first expanding using expand-web-form.

#+begin_src lisp
(:@+ |defun for use in org files|
  (defmacro shadow-defun (name args &body body &environment env)
    ;; SBCL needs this decl - does something that makes it
    ;; thing named-code-blocks is lexical
    (declare (special named-code-blocks))
    (funcall *save-defun*
	     `(defun ,name ,(expand-web-form args)
		,@(expand-web-form body)) env)))
#+end_src

The ABCL compiler function is modified to check whether we're working with an org file,
and, if so, first call expand-web-form on the body, which is it's second argument.

#+begin_src lisp
(:@+ |hook abcl's compile-defun|
  (progn #+ABCL
  (defun jvm::compile-defun (&rest args)
    (if (in-a-context-where-we-should-use-expand-web-form)
	(apply *save-compile-defun*
	       (first args) (expand-web-form (second args))
	       (cddr args))
	(apply *save-compile-defun* args)
	))))
#+end_src

*** Hooking load and compile-file

Again, we'll need to save the values of the original functions to restore them 
after we've changed them.

#+begin_src lisp
(:@+ |defvars|
  (defvar *save-load* #'load)
  (defvar *save-compile-file* #'compile-file)
  )
#+end_src

During loading we want to gather the code chunks to make them available for our
shadow-defun, and rebind defun to be our shadow defun. We only do this if we are
loading an org file. Note the declaration of named-code-blocks as special. We
shouldn't need that, as it is defined using defvar however, SBCL does something
funny and will consider it lexical unless we explicitly say it's special.

These are written as we want to defer the changes until the rest of this
file has been read.

#+begin_src lisp
(:@+ |hook load|
  (without-cl-locked
      (defun load (path &rest args)
	(if (in-a-context-where-we-should-use-expand-web-form)
	    (letf-without-cl-lockeds (((macro-function 'defun) (macro-function 'shadow-defun)))
	      (let ((named-code-blocks (and (probe-file path) (gather-code-chunks path ))))
		(declare (special named-code-blocks))
		(with-literate-syntax
		  (apply *save-load* path args))))
	    (apply *save-load* path args)))))
#+end_src

compile-file is hooked in exactly the same way.

#+begin_src lisp
(:@+ |hook compile-file|
  (without-cl-locked
      (defun compile-file (path &rest args)
	(if (in-a-context-where-we-should-use-expand-web-form)
	    (letf-without-cl-lockeds (((macro-function 'defun) (macro-function 'shadow-defun)))
	      (let ((named-code-blocks (gather-code-chunks path )))
		(declare (special named-code-blocks))
		(with-literate-syntax
		  (apply *save-compile-file* path args))))
	    (apply *save-compile-file* path args)))))
#+end_src

*** Installing the hooks

All of the patching needs to be done inside an eval-when. It's in a code chunk
so it can easily placed at the end of the file.

#+begin_src lisp
(:@+ |set up hooks|
 (:@ |hook abcl's compile-defun|) 
 #-(or allegro lispworks)
 (eval-when (:load-toplevel :execute)
   (:@ |defun for use in org files|)
   (:@ |hook load|)
   (:@ |hook compile-file|))
)
#+end_src

Warn if we're not one of the lisps we've handled.

#+begin_src
#-(or abcl sbcl ccl cmu ecl lispworks)
(warn "Didn't know how to patch a common lisp defined defun or defmacro, so load and compile of org files won't work. Use the tangled file")
#+end_src

For for testing we want to be able to unhook and undefine everything everything.

#+begin_src lisp
(defun erase-lilith ()
  (without-cl-locked
    (setf (symbol-function 'load) *save-load*)
    (setf (symbol-function 'compile-file) *save-compile-file*)
    #+ABCL
    (setf (symbol-function 'jvm::compile-defun) *save-compile-defun*))
  (let ((lilith-package (find-package 'lp)))
    (do-symbols (s 'lp)
      (when (eq (symbol-package s) lilith-package)
	(when (boundp s) (makunbound s))
	(when (fboundp s) (makunbound s))))
    (rename-package lilith-package (gensym))))
#+end_src

<<lispworks implementation>>
*** Lispworks implementation.

LispWorks can add an
[[http://www.lispworks.com/documentation/lw70/LW/html/lw-682.htm][advice]] to a
function to change its default behavior, we can take advantage of this facility
to hook load and compile-file. As I don't know whether one can advise a defmacro
form, we fall back to the general method.

Please note that this hasn't been tested, and that I am uncertain whether
lispworks needs to hook something in the compiler or whether it expands defun
during compilation.

#+BEGIN_SRC lisp
#+lispworks
(progn
  (lw:defadvice (cl:load literate-load :around) (&rest args)
      (if (in-a-context-where-we-should-use-expand-web-form)
	  (letf-without-cl-lockeds (((macro-function 'defun) (macro-function 'shadow-defun)))
	    (let ((named-code-blocks (and (probe-file path) (gather-code-chunks path ))))
	      (declare (special named-code-blocks))
	      (with-literate-syntax
		(apply #'lw:call-next-advice args))))
	  (apply #'lw:call-next-advice args)))

  (lw:defadvice (cl:compile-file :around) (&rest args)
      (if (in-a-context-where-we-should-use-expand-web-form)
	  (letf-without-cl-lockeds (((macro-function 'defun) (macro-function 'shadow-defun)))
	    (let ((named-code-blocks (and (probe-file path) (gather-code-chunks path ))))
	      (declare (special named-code-blocks))
	      (with-literate-syntax
		(apply #'lw:call-next-advice args))))
	  (apply #'lw:call-next-advice args)))
  )
#+END_SRC

** ASDF support for org file as source code

Define a new source file class for org files. The class name needs to be in the ASDF package.
With this one uses :org as the component type in your system defs.

#+BEGIN_SRC lisp
(eval-when (:load-toplevel :execute)
  (defclass asdf::org (asdf:cl-source-file)
  ((asdf::type :initform "org")))  
  (export (list (intern "ORG" 'asdf)) :asdf)) ; was having package problems using asdf:org or asdf::org
#+END_SRC

Here's an example of its use. Now when you load the system 
~readme.org~ will loaded as a lisp source file.
#+BEGIN_SRC lisp :load no
(asdf:defsystem literate-demo
  :components ((:module demo :pathname "./"
                        :components ((:org "readme"))))
  :depends-on (:lilith))
#+END_SRC

To implement this behavior, we put an :around method on asdf:perform that sets the readtable 
to *org-readtable*.
#+BEGIN_SRC lisp
(defmethod asdf:perform :around (o (c asdf::org))
  (with-literate-syntax
    (call-next-method)))
#+END_SRC


* Release this file
When a new version of [[./lilith.lisp]] can release from this file,
the following code should execute.
#+caption: a demo code to tangle current org file.
#+BEGIN_SRC lisp :load no
(tangle-org-file
 (format nil "~a/lilith.org"
         (asdf:component-pathname (asdf:find-system :lilith))))
#+END_SRC

* Test cases
:PROPERTIES:
:literate-load: test
:END:      
** Preparation
Now it's time to validate some functions.
The [[https://common-lisp.net/project/fiveam/][FiveAM]] library is used to test.

#+BEGIN_SRC lisp :load test
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package :fiveam)
    #+quicklisp (ql:quickload :fiveam)
    #-quicklisp (asdf:load-system :fiveam)))
(5am:def-suite lilith-suite :description "The test suite of lilith.")
(5am:in-suite lilith-suite)
#+END_SRC
** test groups
*** test for reading org code block header-arguments
<<block header test>>
#+BEGIN_SRC lisp :load test
(5am:test read-org-code-block-header-arguments
  (5am:is (equal nil (read-org-code-block-header-arguments "" 0)))
  (5am:is (equal '(:load :no) (read-org-code-block-header-arguments " :load no  " 0)))
  (5am:is (equal '(:load :no) (read-org-code-block-header-arguments " :load no" 0))))
#+END_SRC

*** tests for web syntax
**** a simple test

define local variables 1
#+BEGIN_SRC lisp :load test
(:@+ |local variables part 1 for test1|
    (x 1))
#+END_SRC

a code block contains other code block name.
#+BEGIN_SRC lisp :load test
(:@+ |local variables for test1|
    (:@ |local variables part 1 for test1|)
    (y 2))
#+END_SRC

define a function
#+BEGIN_SRC lisp :load test
(defun web-syntax-test1 ()
  (let ((a 1)
        (:@ |local variables for test1|))
    (list a x y)))
#+END_SRC

Let's test this function
#+BEGIN_SRC lisp :load test
(5am:test web-syntax-case1
  (5am:is (equal '(1 1 2) (web-syntax-test1))))
#+END_SRC
**** special cases
***** dotted list to expand
#+BEGIN_SRC lisp :load test
(5am:test web-syntax-special-case-for-dotted-list
  (5am:is (equal '(a . b) (expand-web-form '(a . b)))))
#+END_SRC

*** Other tests
#+begin_src lisp :load test
 (:@ |tests|)
#+end_src
** run all tests in this library
this function is the entry point to run all tests and return true if all test cases pass.
#+BEGIN_SRC lisp :load test
(defun run-test ()
  (5am:run! 'lilith-suite))
#+END_SRC

** run all tests in demo project
To run all tests in demo project ~literate-demo~, please load it by yourself.


* Bugs
- Doesn't work in Allegro until we can hook compile-defun.
- (:@) that's not inside a defun, which is saved for evaluation later, does't work. 
For example: (5am:test recursive-assoc (5am:is (:@ |test|))) won't work because '(:@ |test|)
is saved by 5am and only evaluated when the test is called. At that point the load
is finished and so the appropriate context is no longer available


* Ideas and Plans

- A way to indicate that some portion of text should be used as a docstring. 
- Better formatting/linking of code chunks.
- Fix indentation for tangled code chunks
- Fix eval and code navigation in emacs within org files. 
- Quick preview of code block with all substitutions
- Redirect pieces of the file to different tanged files, e.g. to embed and export asd, test files.
- Add xref links in exports 
- C-c C-c eval taking into account code chunks. What should happen when we eval a code chunk? Eval any users?
- A way to have long texts without having to escape for lisp. Tried (:@. but it's a pain.

** Final setup   

#+begin_src lisp
(:@ |set read table dispatch functions|)
(:@ |set up hooks|)
#+end_src

* References
- [[https://github.com/jingtaozf/literate-lisp ][Literate Lisp]] by Jingtao Xu, the original project from which Lilith was forked.
- [[http://www.literateprogramming.com/knuthweb.pdf][Literate. Programming.]] by [[https://www-cs-faculty.stanford.edu/~knuth/lp.html][Donald E. Knuth]]
- [[http://www.literateprogramming.com/][Literate Programming]]  a site of literate programming
- [[https://www.youtube.com/watch?v=Av0PQDVTP4A][Literate Programming in the Large]] a talk video from Timothy Daly,one of the original authors of [[https://en.wikipedia.org/wiki/Axiom_(computer_algebra_system)][Axiom]].
- [[https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming][literate programming in org babel]]
- [[https://github.com/limist/literate-programming-examples][A collection of literate programming examples using Emacs Org mode]]
- [[https://github.com/xtaniguchimasaya/papyrus][papyrus]] A Common Lisp Literate Programming Tool in markdown file
