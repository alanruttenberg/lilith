;;; This file is automatically generated from file `tangle.org'.
;;; It is not designed to be readable by a human.
;;; It is generated to load by a common lisp vendor directly without depending on `literate-lisp'.
;;; Please read file `tangle.org' to find out the usage and implementation detail of this source file.

(in-package :common-lisp-user)
(defpackage :literate-lisp
  (:use :cl)
  (:nicknames :lp)
  (:export :tangle-org-file :with-literate-syntax :@= :@+= )
  (:documentation "a literate programming tool to write common lisp codes in org file."))
(pushnew :literate-lisp *features*)
(in-package :literate-lisp)

(defvar debug-literate-lisp-p nil)
(declaim (type boolean debug-literate-lisp-p))


(defun load-p (feature)
  (case feature
    ((nil :yes) t)
    (:no nil)
    (:test (find :literate-test *features* :test #'eq))))

(defun read-org-code-block-header-arguments (string begin-position-of-header-arguments)
  (with-input-from-string (stream string :start begin-position-of-header-arguments)
    (let ((*readtable* (copy-readtable nil))
          (*package* #.(find-package :keyword))
          (*read-suppress* nil))
       (loop for elem = (read stream nil)
                     while elem
                     collect elem))))

(defun start-position-after-space-characters (line)
  (loop for c of-type character across line
        for i of-type fixnum from 0
        until (not (find c '(#\Tab #\Space)))
        finally (return i)))

(defvar org-lisp-begin-src-id "#+begin_src lisp")
(defun sharp-space (stream a b)
  (declare (ignore a b))
  (when (and *tangling-to-stream* *tangle-keep-org-text*)
    (terpri *tangling-to-stream*))
  (loop for line = (read-line stream nil nil)
        until (null line)
        for start1 = (start-position-after-space-characters line)
        do (when debug-literate-lisp-p
             (format t "ignore line ~a~%" line))
	   (when *tangling-to-stream*
	     (if *tangling-verbatim*
		 (write-line line *tangling-to-stream*)
		 (unless (or (eql 0 (position #\# line :test 'char=))
			     (ppcre::scan "^\\s*$" line)
			     (not *tangle-keep-org-text*))
		   (write-string ";; " *tangling-to-stream*)
		   (write-line line *tangling-to-stream*))))
        until (and (equalp start1 (search org-lisp-begin-src-id line :test #'char-equal))
                   (let* ((header-arguments (read-org-code-block-header-arguments line (+ start1 (length org-lisp-begin-src-id)))))
                     (load-p (getf header-arguments :load :yes)))))
  (when (and *tangling-to-stream* *tangle-keep-org-text*)
    (terpri *tangling-to-stream*))
  (values))

;;; If X is a symbol, see whether it is present in *FEATURES*. Also
;;; handle arbitrary combinations of atoms using NOT, AND, OR.
(defun featurep (x)
  (typecase x
    (cons
     (case (car x)
       ((:not not)
        (cond
          ((cddr x)
           (error "too many subexpressions in feature expression: ~S" x))
          ((null (cdr x))
           (error "too few subexpressions in feature expression: ~S" x))
          (t (not (featurep (cadr x))))))
       ((:and and) (every #'featurep (cdr x)))
       ((:or or) (some #'featurep (cdr x)))
       (t
        (error "unknown operator in feature expression: ~S." x))))
    (symbol (not (null (member x *features* :test #'eq))))
    (t
      (error "invalid feature expression: ~S" x))))

(defun read-feature-as-a-keyword (stream)
  (let ((*package* #.(find-package :keyword))
        ;;(*reader-package* nil)
        (*read-suppress* nil))
    (read stream t nil t)))

(defun handle-feature-end-src (stream sub-char numarg)
  (when debug-literate-lisp-p
    (format t "found #+END_SRC,start read org part...~%"))
  (funcall #'sharp-space stream sub-char numarg))

(defun read-featurep-object (stream)
  (read stream t nil t))

(defun read-unavailable-feature-object (stream)
  (let ((*read-suppress* t))
    (read stream t nil t)
    (values)))

(defun sharp-plus (stream sub-char numarg)
  (let ((feature (read-feature-as-a-keyword stream)))
    (when debug-literate-lisp-p
      (format t "found feature ~s,start read org part...~%" feature))
    (cond ((eq :END_SRC feature) (handle-feature-end-src stream sub-char numarg))
          ((featurep feature)    (read-featurep-object stream))
          (t                     (read-unavailable-feature-object stream)))))

(defvar *org-readtable* (copy-readtable))

(set-dispatch-macro-character #\# #\space #'sharp-space *org-readtable*)
(set-dispatch-macro-character #\# #\+ #'sharp-plus *org-readtable*)

(defvar *tangling-to-stream* nil) ;; bound to the output stream when we are tangling
(defvar *tangling-verbatim* nil) ;; mostly for debugging - copy even the org mode comments
(defvar *tangle-keep-org-text* nil)
(defun tangle-org-file (org-file &key
				   (keep-test-codes nil)
				   (output-file (make-pathname :defaults org-file
							       :type "lisp"))
				   verbatim
				   (keep-org-text t))
  (let ((*features* (if keep-test-codes
			*features*
			(remove :literate-test *features* :test 'eq)))
	(code-blocks (org-file-gather-code-blocks org-file))
	(*tangling-verbatim* verbatim)
	(*tangle-keep-org-text*  keep-org-text))

    (with-open-file (output output-file :direction :output
					:if-does-not-exist :create
					:if-exists :supersede)
      (unless *tangling-verbatim*
	(format output ";;; This file is automatically generated from the literate-lisp file '~a.~a'.~%"
		(pathname-name org-file) (pathname-type org-file))
	(format output ";;; It is meant to be loaded by a common lisp directly, without depending on literate-lisp.~%"))
      (if *tangle-keep-org-text*
	  (format output "~{~a~%~}~%"
		  '(";;; This file keeps all text in the original file as lisp comments, except"
		    ";;; for the org-mode comments and directives."))
	  (format output "~{~a~%~}~%"
		  '(";;; The file is not intended to be read directly as it omits all non-code text from the source."
		    ";;; See the source for full usage and documentation")))
      (let ((*tangling-to-stream* output))
	(each-source-block-as-string
	 org-file
	 (lambda(block)
	   (if (search "defmacro defun-literate" block)
	       (write-string block output) ;; don't replace defun-literate in the defun-literate definition
	       (if (ppcre::scan "\\s*\\(:@\\+?=" block)
		   ;; comment out @+=, @=
		   (format *tangling-to-stream* "~{;; ~a~%~}" (cl-ppcre::split "\\n" block))
		   (write-string (cl-ppcre::regex-replace-all
			      "defun-literate"
			      (maybe-substitute-code-block block code-blocks)
			      "defun") output)))
	(when *tangling-verbatim*
	  (format *tangling-to-stream* "#+END_SRC~%"))))
	))))

(defun each-source-block-as-string (org-file fn)
  "Call fn on each source code block string in the org file"
    (with-open-file (input org-file)
      (block read-org-files
	(loop for nil = (sharp-space input nil nil)
	      until (eq (peek-char nil input nil :eof) :eof)
	      ;; read codes in code block until reach `#+end_src'
	      do (loop with output = (make-string-output-stream)
		       for line = (read-line input nil nil)
		       do
			  (cond ((null line)
				 (error "End of file while in source block '~a'" (get-output-stream-string output)))
				((string-equal "#+end_src" (string-trim '(#\Tab #\Space) line))
				 (when debug-literate-lisp-p
				   (format t "reach end of source code block.~%"))
				 (funcall fn (get-output-stream-string output))
				 (return t))
				(t (when debug-literate-lisp-p
				     (format t "read code line:~s~%" line))
				   (write-line line output))))))))

(defun get-forms-as-strings (string)
  (loop for lastpos = 0 then pos
	with stream = (make-string-input-stream string)
	for pos = (if (= (file-position stream) (length string))
		      :eof
		      (let ((*read-suppress* t))
			(read stream nil nil) ; need this because you might have "#+nil foo" in a src block
			(file-position stream)))
	until (eq pos :eof)
	collect (subseq string lastpos pos)))

(defun each-source-form-as-string (org-file fn)
  (each-source-block-as-string
   org-file
   (lambda (block) (map nil fn (get-forms-as-strings block)))))

(defun each-non-code-block-source-form-as-string (org-file fn)
  (each-source-block-as-string
   org-file
   (lambda (block)
     (loop for form in (get-forms-as-strings block)
	   unless (cl-ppcre::scan "^\\s*\\((@[+]{0,1}=)\\s+" form)
	     do (funcall fn form)))))

(defun read-forms-from-string (string)
  (with-input-from-string (s string)
    (loop for form = (read s nil :eof)
	  until (eq form :eof)
	  collect form)))

(defun org-file-gather-code-blocks (org-file)
  (let ((code-blocks (make-hash-table :test 'equalp)))
    (each-source-form-as-string
     org-file
     (lambda(block)
       ;; (@= , @+=
       (cl-ppcre::register-groups-bind (directive name body)
	   ("(?s)^\\s*\\((:?@[+]{0,1}=)\\s+\\|([^|]+)\\|\\s*(.*)\\)" block)
	 (if (equal directive "@+=")
	     (progn
	       (assert (gethash name code-blocks) () "@+= ~a but that block hasn't been seen before" name)
	       (push body (gethash name code-blocks)))
	     (progn
	       (assert (not (gethash name code-blocks)) () "@= ~a found but there's already a code block by that name" name)
	       (setf (gethash (string name) code-blocks) (list body)))))))
    code-blocks))

(defun replace-all (string regex function &rest which)
  (cl-ppcre::regex-replace-all
   regex string
   (lambda (target-string start end match-start match-end reg-starts reg-ends)
     (declare (ignore target-string start end ))
     (apply function
	    (loop for group in which
		  if (= group 0)
		    collect (subseq string match-start match-end)
		  else
		    collect (subseq string (aref reg-starts (1- group)) (aref reg-ends (1- group))))))))

(defvar *trace-substitution* nil)
;; make some effort here to indent reasonably
;; first find the indentation of block reference
;; Then pad by that amount each line of the replacement, first removing initial spaces
(defun maybe-substitute-code-block (input code-blocks)
  ;; looking for :@, :@@
  (replace-all input "(\\(:(@{1,2})\\s*\\|([^|]+)\\|\\s*\\))"
	       (lambda(whole op name)
		 ;;	(declare (ignore whole))
		 (let* ((pos (some (lambda(e) (search whole e :test 'char=))
				   (cl-ppcre::split "\\n" input)))
			(indent (subseq (load-time-value (format nil "~80:a" " ")) 0 pos)))
		   (assert (gethash name code-blocks) () "Code block '~a' called for, but not defined" name)
		   (if (member name *trace-substitution* :test 'equalp)
		       (error "Circularity in code blocks: |~a| uses ~{|~a|~^ uses~}" name (reverse *trace-substitution*))
		       (let ((*trace-substitution* (cons name *trace-substitution*)))
			 (let ((sub (format nil ";; Using |~a|~%~{~a~}" name
					    (mapcar (lambda(e)
						      (format nil "~a"
							      (ppcre::regex-replace-all
							       "(?m)(^\\s*)"
							       (maybe-substitute-code-block e code-blocks)
							       indent)))
						    (gethash name code-blocks)))))
			   (if (equal op "@@")
			       sub
			       (format nil "(~a)" sub)))))))
		 1 2 3))

(defmacro with-literate-syntax (&body body)
  `(let ((*readtable* *org-readtable*))
     ,@body))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defclass asdf::org (asdf:cl-source-file)
    ((asdf::type :initform "org")))
  (export '(asdf::org) :asdf))

(defmethod asdf:perform :around (o (c asdf:org))
  (literate-lisp:with-literate-syntax
    (call-next-method)))

(defmacro letf-without-package-locks (bindings &body body)
  (if (null bindings)
      `(progn ,@body)
      (let ((save (gensym)))
	`(let ((,save ,(caar bindings)))
	   (letf-without-package-locks ,(cdr bindings)
	     (unwind-protect (progn (#+SBCL sb-ext::without-package-locks #-SBCL progn
				     (setf ,(caar bindings) ,(second (car bindings))))
				    ,@body )
	       (#+SBCL sb-ext::without-package-locks #-SBCL progn
		(setf ,(caar bindings) ,save))))))))

#+lispworks
(lw:defadvice (cl:load literate-load :around) (&rest args)
  (literate-lisp:with-literate-syntax
      (apply #'lw:call-next-advice args)))

#+(or abcl sbcl)
(eval-when (:load-toplevel :execute)
  (defvar *save-load* #'load)
  (defvar *save-defun* (macro-function 'defun))
  (defvar *save-compile-file* #'compile-file)
  #+ABCL
  (defvar *save-compile-defun* #'jvm::compile-defun)
  ;; In ABCL it would seem it requires hooking the compiler, as defun isn't expanded as usual
  #+ABCL
  (defun jvm::compile-defun (&rest args)
    (if (or (and *load-truename* (equal (pathname-type *load-truename*) "ORG"))
	    (and *compile-file-pathname* (equal (pathname-type  *compile-file-pathname*) "ORG")))
	(apply *save-compile-defun*
	       (first args) (expand-web-form (second args))
	       (cddr args))
	(apply *save-compile-defun* args)
	))

  (defmacro shadow-defun (name args &body body &environment env)
    ;; SBCL needs this decl - does something that makes it
    ;; thing named-code-blocks is lexical
    (declare (special named-code-blocks))
    (funcall *save-defun*
	     `(defun ,name ,(expand-web-form args)
		,@(expand-web-form body)) env))

  (#+SBCL sb-ext::without-package-locks #-SBCL progn
   (defun load (&rest args)
     (if (equal (pathname-type (car args)) "org")
	 (letf-without-package-locks (((macro-function 'defun) (macro-function 'shadow-defun)))
	   (let ((named-code-blocks (org-file-gather-code-blocks (car args) )))
	     (declare (special named-code-blocks))
	     (literate-lisp:with-literate-syntax
	       (apply *save-load* args))))
	 (apply *save-load* args))))

  ;; in SBCL defun seems to be expanded during compile, so it works too
  ;; but watch out for lexical shenanigans
  (#+SBCL sb-ext::without-package-locks #-SBCL progn
   (defun compile-file (&rest args)
     (if (equal (pathname-type (car args)) "org")
	 (letf-without-package-locks (((macro-function 'defun) (macro-function 'shadow-defun)))
	   (let ((named-code-blocks (org-file-gather-code-blocks (car args) )))
	     (declare (special named-code-blocks))
	     (literate-lisp:with-literate-syntax
	       (apply *save-compile-file* args))))
	 (apply *save-compile-file* args))))
)

(defvar named-code-blocks nil)

(defmacro :@= (name &body body)
  (declare (ignore name body))
  nil)

  ;; (if (nth-value 1 (gethash name named-code-blocks))
  ;;   (warn "code block ~a has been updated" name))
  ;; (setf (gethash (string name) named-code-blocks) body)
  ;; `(progn
  ;;    #+lispworks
  ;;    (dspec:def (type ,name))
  ;;    ',name))

(defmacro :@+= (name &body body)
  (declare (ignore name body))
  nil)
  ;; (setf (gethash name named-code-blocks)
  ;; 	(append (gethash (string name) named-code-blocks)
  ;; 		body)))

(defmacro with-code-block ((name codes) &body body)
  (let ((present-p (gensym "PRESENT-P"))
        (code-block-name (gensym "NAME")))
    `(let ((,code-block-name ,name))
       (let* ((,present-p (gethash (string ,code-block-name) named-code-blocks))
	      (,codes (mapcan 'read-forms-from-string ,present-p)))
         (unless ,present-p
           (error "Can't find code block:~a" ,code-block-name))
         ,@body))))

;; FIXME: Has trouble with dotted lists
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun expand-web-form (form)
    (if (atom form)
      form
      (loop for previous-form = nil then left-form
            for left-form = form then (cdr left-form)
            until (null left-form)
            when (listp (car left-form))
              do (case (caar left-form)
                   (quote nil); ignore a quote list.
                   (:@ ; replace item as its actual codes
                    (with-code-block ((second (car left-form)) codes)
                        (setf (car left-form) codes)))
                   (:@@ ; concentrate codes to `form'.
                    (with-code-block ((second (car left-form)) codes)
                      (unless codes
                        (error "code block ~a is null for syntax :@@" (second (car left-form))))
                      ;; support recursive web syntax in a code block by expanding the defined code block
                      (let* ((copied-codes (expand-web-form (copy-tree codes)))
                             (last-codes (last copied-codes)))
                        ;; update next form
                        (setf (cdr last-codes) (cdr left-form))
                        ;; update left-form
                        (setf left-form last-codes)
                        (if previous-form
                          (setf (cdr previous-form) copied-codes)
                          (setf form copied-codes)))))
                   (t (setf (car left-form) (expand-web-form (car left-form)))))
            finally (return form)))))
