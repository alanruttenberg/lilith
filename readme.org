# -*- encoding:utf-8 Mode: POLY-ORG;  -*- --- 
* Table of Contents                                                   :TOC:
- [[#introducation][Introducation]]
- [[#a-demo-lisp-package][A demo lisp package]]
  - [[#package-definition][package definition]]
  - [[#a-demo-function-to-a-recursive-assoc-implementation][a demo function to a recursive assoc implementation]]

* Introducation
This is a demo project to show one way of how to use [[http://www.literateprogramming.com/][literal programming]] in common lisp.

The implementation details of [[https://github.com/jingtaozf/literate-lisp][literate-lisp]] can be found in file [[./tangle.org]].

* A demo lisp package
** package definition
Firstly we define a new package for this demo project and switch to it.
#+BEGIN_SRC lisp
(in-package :common-lisp-user)
(defpackage :literate-demo (:use :cl))
(in-package :literate-demo)
#+END_SRC
** a demo function to a recursive assoc implementation
As a demo project, we just show a demo function ~recursive-assoc~ here.
the function [[http://clhs.lisp.se/Body/f_assocc.htm][cl:assoc]] only find first level item from an [[http://clhs.lisp.se/Body/26_glo_a.htm#association_list][association list]], when I want to
find item from an association list contains many other association list in depth level, I
have to write codes like this which will lead the codes too long.
#+BEGIN_SRC lisp
#+test(assoc :b (assoc :a '((:a . ((:b . c))))))
#+END_SRC
To simplify the expression, I write a macro ~recursive-assoc~ to simply it to the following form
#+BEGIN_SRC lisp
#+test(recursive-assoc '((:a . ((:b . c)))) :a :b)
#+END_SRC

It also provides a function implementation ~funcall-recursive-assoc~ as an alternative of ~recursive-assoc~.
#+BEGIN_SRC lisp
(defun funcall-recursive-assoc (alist &rest recursive-properties)
  (loop with current-alist = alist
        for property in recursive-properties
        until (null current-alist)
        do (setf current-alist (cdr (assoc property current-alist)))
        finally (return current-alist)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun expand-recursive-assoc (alist recursive-properties)
    (if (cdr recursive-properties)
      (expand-recursive-assoc `(cdr (assoc ,(car recursive-properties) ,alist))
                              (cdr recursive-properties))
      `(cdr (assoc ,(car recursive-properties) ,alist)))))

(defmacro recursive-assoc (alist &rest recursive-properties)
  (when recursive-properties
    (expand-recursive-assoc alist recursive-properties)))

#+END_SRC

for example, you can use it like this,which get ~:b~ part of the sub alist 
which is ~:a~ part of the original list.
#+BEGIN_SRC lisp
#+test(equal 'c (recursive-assoc '((:a . ((:b . c)))) :a :b))
#+END_SRC
