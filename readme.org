# -*- encoding:utf-8 Mode: POLY-ORG;  -*- --- 
#+Startup: noindent
#+MACRO: imglnk @@html:<a href="$1"><img src="$2"></a>@@

#+ATTR_HTML: title="Build Status"
[[https://travis-ci.com/jingtaozf/literate-lisp][file:https://travis-ci.com/jingtaozf/literate-lisp.svg?branch=master]]

* Table of Contents                                                   :TOC:
- [[#introducation][Introducation]]
- [[#preparation][Preparation]]
  - [[#install-polymode-in-emacs][install polymode in emacs]]
- [[#a-demo-lisp-package][A demo lisp package]]
  - [[#prepare-the-asd-definition-file][Prepare the asd definition file]]
  - [[#package-definition][package definition]]
  - [[#a-demo-function-to-a-recursive-assoc-implementation][a demo function to a recursive assoc implementation]]

* Introducation
This is a demo project to show a way how to use [[http://www.literateprogramming.com/][literal programming]] in common lisp.

The implementation details of [[https://github.com/jingtaozf/literate-lisp][literate-lisp]] can be found in file [[./tangle.org]] ([[./tangle.pdf][pdf version]]).

* Preparation
** install polymode in emacs
The org file should be opened with [[https://polymode.github.io/][polymode]],the following elisp scripts should be added in .emacs
#+BEGIN_SRC elisp
(use-package poly-org
    :ensure t)
#+END_SRC

* A demo lisp package
** Prepare the asd definition file

We use the original asd definition file, so file [[./literate-demo.asd]] has to be added firstly
(The documentation of extended asdf syntax can be found in [[https://github.com/jingtaozf/literate-lisp/blob/master/tangle.org#make-asdf-handle-org-file-correctly][tangle.org]]).

To use the extended asdf syntax, we have to load [[https://github.com/jingtaozf/literate-lisp][literate-lisp]] firstly in asd file like this
#+BEGIN_SRC lisp :tangle no
(eval-when (:load-toplevel :execute)
  (asdf:load-system :literate-lisp))
#+END_SRC

Now define the asd system for this demo package
#+BEGIN_SRC elisp :tangle no
(asdf:defsystem literate-demo
  :author "Xu Jingtao <jingtaozf@gmail.com>"
  :version "0.1"
  :licence "MIT"
  :serial t
  :description "an demo project of literate-lisp"
  :components ((:module org :pathname "./"
                        :components ((:org "readme"))))
  :properties ((version "0.1"))
  :depends-on (:literate-lisp))
#+END_SRC
Which will load this [[./readme.org]] directlly as a lisp source file.

The whole content of asd file can be found in [[./literate-demo.asd]].

** package definition

Now we can add both documents and lisp codes in this org file directly in emacs.

Firstly we define a new package for this demo project and switch to it.
#+BEGIN_SRC lisp
(in-package :common-lisp-user)
(defpackage :literate-demo (:use :cl))
(in-package :literate-demo)
#+END_SRC
** a demo function to a recursive assoc implementation
As a demo project, we just show a demo function ~recursive-assoc~ here.

The function [[http://clhs.lisp.se/Body/f_assocc.htm][cl:assoc]] only find first level item from an [[http://clhs.lisp.se/Body/26_glo_a.htm#association_list][association list]], when I want to
find item from an association list contains many other association list with deep level, I
have to write codes like this which will lead the codes too long.
#+BEGIN_SRC lisp :tangle test
(cdr (assoc :b (cdr (assoc :a '((:a . ((:b . c))))))))
#+END_SRC
To simplify the expression, I write a macro ~recursive-assoc~ to simply it to the following form
#+BEGIN_SRC lisp :tangle no
(recursive-assoc '((:a . ((:b . c)))) :a :b)
#+END_SRC

It also provides a function implementation ~funcall-recursive-assoc~ as an alternative of ~recursive-assoc~.
#+BEGIN_SRC lisp
(defun funcall-recursive-assoc (alist &rest recursive-properties)
  (loop with current-alist = alist
        for property in recursive-properties
        until (null current-alist)
        do (setf current-alist (cdr (assoc property current-alist)))
        finally (return current-alist)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun expand-recursive-assoc (alist recursive-properties)
    (if (cdr recursive-properties)
      (expand-recursive-assoc `(cdr (assoc ,(car recursive-properties) ,alist))
                              (cdr recursive-properties))
      `(cdr (assoc ,(car recursive-properties) ,alist)))))

(defmacro recursive-assoc (alist &rest recursive-properties)
  (when recursive-properties
    (expand-recursive-assoc alist recursive-properties)))

#+END_SRC

for example, you can use it like this,which get ~:b~ part of the sub alist 
which is ~:a~ part of the original list.
#+BEGIN_SRC lisp :tangle test
(equal 'c (recursive-assoc '((:a . ((:b . c)))) :a :b))
#+END_SRC
