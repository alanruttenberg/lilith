# -*- encoding:utf-8 Mode: POLY-ORG;  -*- --- 
* Table of Contents                                                   :TOC:
- [[#introduce][Introduce]]
- [[#the-syntax-for-common-lisp-side][the syntax for common lisp side]]
  - [[#--followed-with-a-space]["# (# followed with a space)"]]
  - [[#]["#+"]]
- [[#a-demo-lisp-package][A demo lisp package]]
  - [[#package-definition][package definition]]
  - [[#utilities][Utilities]]

* Introduce
This is a demo project to show one way of how to use literal programming in common lisp.

There are another lisp project [[https://github.com/xtaniguchimasaya/papyrus][papyrus]] to do the similiar thing but it use markdown file format.

By using common lisp package [[https://github.com/jingtaozf/org-reader][org-reader]] , emacs [[https://orgmode.org/][org mode]] and elisp library [[https://polymode.github.io/][polymode]], 
we can do it perfectly in one org file with both documentation and source codes,and this org file
will works well with [[https://common-lisp.net/project/slime/][SLIME]].
* the syntax for common lisp side 

There are two common lisp readers are defined, one for "# "(# followed with a space) and one for "#+".
** "# (# followed with a space)"
after a "# " is found, all lines after it will be ignored unless it find a line "#+BEGIN_SRC lisp"
which means some lisp codes is found in org file, then it will switch to use a normal lisp reader to read
the lisp codes untils it read a "#+".
** "#+"
When it read a "#+", it will test if it is "#+END_SRC" which means the end of lisp codes in an org file,
if it is, it will do things like it meet "# ",otherwise it will do it like the original lisp syntax.

So an org file should start with "# " to make the lisp reader into the org syntax.I usually put this in my
first org file
#+BEGIN_SRC org
# -*- encoding:utf-8 Mode: POLY-ORG;  -*- --- 
#+END_SRC
* A demo lisp package
** package definition
Firstly we define a new package for this demo project and switch to it.
#+BEGIN_SRC lisp
(in-package :common-lisp-user)
(defpackage :org-demo (:use :cl))
(in-package :org-demo)
#+END_SRC
** Utilities
As a demo project, we just show a demo function ~recursive-assoc~ here.
*** an recursively assoc implementation
function ~recursive-assoc~ is used to call ~assoc~ recursively on the children of an alist. 
#+BEGIN_SRC lisp
(defun funcall-recursive-assoc (alist &rest recursive-properties)
  (loop with current-alist = alist
        for property in recursive-properties
        until (null current-alist)
        do (setf current-alist (cdr (assoc property current-alist)))
        finally (return current-alist)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun expand-recursive-assoc (alist recursive-properties)
    (if (cdr recursive-properties)
      (expand-recursive-assoc `(cdr (assoc ,(car recursive-properties) ,alist))
                              (cdr recursive-properties))
      `(cdr (assoc ,(car recursive-properties) ,alist)))))

(defmacro recursive-assoc (alist &rest recursive-properties)
  (when recursive-properties
    (expand-recursive-assoc alist recursive-properties)))

#+END_SRC

for example, you can use it like this,which get ~:b~ part of the sub alist 
which is ~:a~ part of the original list.
#+BEGIN_SRC lisp
#+test(equal 'c (recursive-assoc '((:a . ((:b . c)))) :a :b))
#+END_SRC
